\documentclass[specialist, substylefile = spbureport.rtx,
    subf,href,colorlinks=true, 12pt]{disser}

% \usepackage[a4paper, mag=1000, includefoot,
%     left=2cm, right=1.5cm, top=2cm, bottom=2cm, headsep=1cm, footskip=1cm]{geometry}

\usepackage[a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage[T1,T2A]{fontenc}

\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm} %for \newtheorem*
\usepackage{bm}
\usepackage[english,russian]{babel}



% c++ code
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}



% \pagestyle{plain}

\newtheorem*{definition}{Определение}
\newtheorem*{example}{Пример}
\newtheorem*{hypothesis}{Гипотеза}
\newtheorem*{question}{Вопрос}
\newtheorem*{algorithm}{Алгоритм}

% \newcommand{\rank}{\mathsf{rank}\ }







\institution{Санкт-Петербургский государственный университет\\
    Математико-механический факультет\\
    Кафедра Статистического Моделирования
}
\title{«Научно-исследовательская работа» (семестр 7)}
\topic{Разработка программных средств и решение задач принятия решений с помощью методов тропической математики.}
\author{Ткаченко Егор Андреевич}
\group{группа 19.Б04-мм}
\sa       {Кривулин Николай Кимович}
\sastatus {д.\,ф.-м.\,н., профессор}
\city{Санкт-Петербург}
\date{2023}


\begin{document}

    \maketitle
    \pagebreak
    \tableofcontents
    \pagebreak

    \intro

    \section{Постановка задачи принятия решений}

    \subsection{Однокритериальная задача парных сравнений}
        Дано $n$ альтернатив $\mathcal{A}_{1},\ldots,\mathcal{A}_{n}$ принятия решения, которые сравниваются попарно. Результаты сравнений записываются в виде матрицы парных сравнений $\bm{A}=(a_{ij})$ порядка $n$, где элемент $a_{ij}>0$ показывает во сколько раз альтернатива $\mathcal{A}_{i}$ превосходит альтернативу $\mathcal{A}_{j}$. Требуется на основе относительных результатов парных сравнений определить вектор $\bm{x}$ абсолютных рейтингов альтернатив.\cite{Decision_making}

    \subsection{Многокритериальная задача парных сравнений}
        Рассмотрим задачу оценки рейтингов альтернатив, в которой $n$ альтернатив $\mathcal{A}_{1},\ldots,\mathcal{A}_{n}$ сравниваются попарно по $m$ критериям. Пусть $\bm{A}_{k}$ обозначает матрицу порядка $n$ результатов парных сравнений альтернатив в соответствии с критерием $k=1,\ldots,m$. Критерии также сравниваются попарно, а результаты их сравнений образуют матрицу $\bm{C}=(c_{kl})$, где $c_{kl}$ показывает во сколько раз критерий $k$ важнее для принятия решения, чем $l$. Необходимо на основе матриц парных сравнений $\bm{C}$ и $\bm{A}_{1},\ldots,\bm{A}_{m}$ найти абсолютный индивидуальный рейтинг каждой альтернативы.\cite{Decision_making}

    \section{Определение тропической математики}

        Max-умножить алгебра --- множество $\mathbb{R}_+ = \{x \in \mathbb{R} | x \geq 0\}$ с операциями $(\oplus, \times)$ --- максимум и умножение.

        След матрицы $\bm{A}=(a_{ij})$ порядка $n$ вычисляется по формуле $\mathop\mathrm{tr}\bm{A}=a_{11}\oplus\cdots\oplus a_{nn}$.

        Спектральным радиусом матрицы $\bm{A}$ называется число, которое вычисляется по формуле
        \begin{equation*}
        \lambda
        =
        \mathop\mathrm{tr}\bm{A}\oplus\cdots\oplus\mathop\mathrm{tr}\nolimits^{1/n}(\bm{A}^{n})
        =
        \bigoplus_{i=1}^{n}{\mathop\mathrm{tr}}^{1/i}(\bm{A}^{i}).
        \end{equation*}

        При условии, что $\lambda\leq1$, определен оператор Клини (звезда Клини), который сопоставляет матрице $\bm{A}$ матрицу
        \begin{equation*}
        \bm{A}^{\ast}
        =
        \bm{I}\oplus\bm{A}\oplus\cdots\oplus\bm{A}^{n-1}
        =
        \bigoplus_{i=0}^{n-1}\bm{A}^{i}.
        \end{equation*}


    \section{Алгоритм решения задачи}
    \begin{itemize}
        \item[1.]
        Для матрицы $\bm{C}$ находится спектральный радиус $\lambda$, составляется матрица $\lambda^{-1}\bm{C}$, а затем в параметрической форме определяется вектор весов критериев
        \begin{equation}
        \bm{w}
        =
        (\lambda^{-1}\bm{C})^{\ast}\bm{v},
        \qquad
        \bm{v}>\bm{0},
        \qquad
        \lambda
        =
        \bigoplus_{i=1}^{m}{\mathop\mathrm{tr}}^{1/i}(\bm{C}^{i}).
        \end{equation}
        \item[2.]
        Если вектор $\bm{w}$ не единственный (с точностью до положительного множителя), то определяются наилучший и наихудший дифференцирующие векторы весов.
        \begin{itemize}
        \item[2.1.]
        Наилучший дифференцирующий вектор весов находится в параметрическом виде с использованием вектора параметров $\bm{v}_{1}$ по формуле:
        \begin{equation}
        \bm{w}_{1}
        =
        \bm{P}(\bm{I}\oplus\bm{P}_{lk}^{-}\bm{P})\bm{v}_{1},
        \qquad
        \bm{v}_{1}
        >
        \bm{0},
        \end{equation}
        где матрица $\bm{P}=(\bm{p}_{j})$ получена из $(\lambda^{-1}\bm{C})^{\ast}$ вычеркиванием линейно зависимых столбцов, матрица $\bm{P}_{lk}$ получена из $\bm{P}=(p_{ij})$ обнулением всех элементов, кроме $p_{lk}$, а индексы $k$ и $l$ определяются, исходя из условий:
        \begin{equation}
        k
        =
        \arg\max_{j}\bm{1}^{T}\bm{p}_{j}\bm{p}_{j}^{-}\bm{1},
        \qquad
        l
        =
        \arg\max_{i}p_{ik}^{-1}.
        \end{equation}
        \item[2.2.]
        Наихудший дифференцирующий вектор весов находится в параметрическом виде с использованием вектора параметров $\bm{v}_{2}$ по формулам:
        \begin{equation}
        \bm{w}_{2}
        =
        (\Delta^{-1}\bm{1}\bm{1}^{T}\oplus\lambda^{-1}\bm{C})^{\ast}\bm{v}_{2},
        \qquad
        \bm{v}_{2}
        >
        \bm{0},
        \qquad
        \Delta
        =
        \bm{1}^{T}(\lambda^{-1}\bm{C})^{\ast}\bm{1}.
        \end{equation}
        \end{itemize}
        \item[3.]
        С помощью векторов $\bm{w}_{1}=(w_{i}^{(1)})$ и $\bm{w}_{2}=(w_{i}^{(2)})$ строятся взвешенные суммы (или одна сумма, когда векторы совпадают) матриц парных сравнений альтернатив:
        \begin{equation}
        \bm{B}
        =
        \bigoplus_{i=1}^{m}w^{(1)}_{i}\bm{A}_{i},
        \qquad
        \bm{D}
        =
        \bigoplus_{i=1}^{m}w^{(2)}_{i}\bm{A}_{i}.
        \end{equation}
        \item[4.]
        Повторяя действия пунктов 1 и 2.1 на основе взвешенной суммы $\bm{B}$ вычисляется вектор рейтингов альтернатив, соответствующий наилучшему дифференцирующему вектору весов критериев.
        
        \item[5.]
        Аналогично, по формулам пунктов 1 и 2.2 на основе взвешенной суммы $\bm{D}$ вычисляется вектор рейтингов альтернатив, соответствующий наихудшему дифференцирующему вектору весов критериев.
        \end{itemize}

       
    \chapter{Разработка структуры для хранения чисел}

    В задаче принятия решений даются матрицы парных сравнений из натуральных и обратных натуральным чисел.
    Для аналитического решения задачи принятия решения структура должна поддерживать операцию умножения, извлечения корня $n$-ой степени и отношение линейного порядка.
    Рациональных чисел $\displaystyle \frac{a}{b}$ не достаточно из-за операции извлечения корня. 
    Необходимо добавить к структуре числа корень целой степени:  $\displaystyle \left(\frac{a}{b}\right)^{1/n}$.

    С такой структурой операции и отношения определяются следующим образом:
    \begin{itemize}
        \item Умножение:
        $$ \left(\frac{a_1}{b_1}\right)^{1/n_1} \times \left(\frac{a_2}{b_2}\right)^{1/n_2} = \left(\frac{a_1^{n_2}a_2^{n_1}}{b_1^{n_2}b_2^{n_1}}\right)^{1/n_1n_2}.$$
        \item Сравнение:
        $$ \left(\frac{a_1}{b_1}\right)^{1/n_1} < \left(\frac{a_2}{b_2}\right)^{1/n_2} \Leftrightarrow
        \left(\frac{a_1^{n_2}}{b_1^{n_2}}\right)^{1/n_1n_2} < \left(\frac{a_2^{n_1}}{b_2^{n_1}}\right)^{1/n_1n_2}\Leftrightarrow
        \frac{a_1^{n_2}}{b_1^{n_2}} < \frac{a_2^{n_1}}{b_2^{n_1}}\Leftrightarrow
        {a_1^{n_2}}{b_2^{n_1}} < {a_2^{n_1}}{b_1^{n_2}}.$$
        \item Обратный элемент относительно умножения:
        $$ \left(\left(\frac{a}{b}\right)^{1/n}\right)^{-1} = \left(\frac{b}{a}\right)^{1/n} $$
    \end{itemize}
    Однако, если использовать такие формулы, числа будут увеличиваться очень быстро.
    Причем, часто $n_1$ и $n_2$ оказываются равными. Это мотивирует использовать НОД в формулах:
    $$n_1 =  n^*_1 \cdot \gcd(n_1, n_2), \qquad n_2 =  n^*_2 \cdot \gcd(n_1, n_2)$$

    \begin{itemize}
        \item Умножение:
        $$ \left(\frac{a_1}{b_1}\right)^{1/n_1} \times \left(\frac{a_2}{b_2}\right)^{1/n_2} = \left(\frac{a_1^{n^*_2}a_2^{n^*_1}}{b_1^{n^*_2}b_2^{n^*_1}}\right)^{1/n^*_1\cdot \gcd(n_1, n_2) \cdot n^*_2}.$$
        \item Сравнение:
        $$ \left(\frac{a_1}{b_1}\right)^{1/n_1} < \left(\frac{a_2}{b_2}\right)^{1/n_2} \Leftrightarrow
        {a_1^{n^*_2}}{b_2^{n^*_1}} < {a_2^{n^*_1}}{b_1^{n^*_2}}.$$
    \end{itemize}


    \chapter{Реализации}

    Помимо класса для хранения чисел и  выполнения операций с ними были реализованы базовые понятия из max-алгебры.

    \section{Матрицы}
    Были реализованы нахождение следа, тропического определителя, транспонированный матрицы, спектрального радиуса, матрицы Клини, проверку линейной зависимости вектора от набора векторов, выбор лнз набора векторов из данных, нахождение лучших и худших дифференцирующих векторов.


    Например, реализация нахождения лучшего дифференцирующего вектора:
    \begin{lstlisting}
    Matrix BestVector()
    {
        T lambda = SpectralRadius();
        Matrix P((*this / lambda).Kleene().Span());

        vector<uint> k;
        T max_value = -1;
        for (uint j = 0; j < P.cols(); j++)
        {
            Matrix col_j(P.getCol(j));
            T tmp = (col_j * col_j.Transpose()).sum();
            if (tmp > max_value)
            {
                k.clear();
                max_value = tmp;
            }
            if (tmp == max_value)
            {
                k.push_back(j);
            }
        }
        vector<uint> l(k.size(), 0);
        for (uint it = 0; it < k.size(); it++)
        {
            for (uint i = 0; i < P.rows(); i++)
            {
                if (P[i][k[it]] < P[l[it]][k[it]])
                {
                    l[it] = i;
                }
            }
        }

        Matrix result(P * (Identity<T>(P.cols()) +
                           P.filter(l[0], k[0]).Transpose() * P));
        for (uint i = 1; i < k.size(); i++)
        {
            result.cbind(P * (Identity<T>(P.cols()) +
                              P.filter(l[1], k[1]).Transpose() * P));
        }

        return result.Span().normCol();
    }
    \end{lstlisting}

    \section{Вывод решения}
    К каждому классу был добавлен метод вывода в latex.
    
    Пример такого метода для класса чисел "MaxMultiFraction":

    \begin{lstlisting}
    std::string to_latex(const MaxMultiFraction &fraction)
    {
        std::string result = to_string(fraction.numerator_);
        if (fraction.denominator_ != 1)
        {
            result = result + "/" + to_string(fraction.denominator_);
        }

        if (fraction.root_ != 1)
        {
            result = "(" + result + ")^{1/" + to_string(fraction.root_) + "}";
        }
        return result;
    }
    \end{lstlisting}
    


% Проделанная работа
% -разработана структура для точного хранения чисел (a/b)^(1/n), для которой определены операции сложения (мах) и умножения;
% -написана программа использующая эту структуру и реализующая решение задачи по заданным матрицам парных сравнений, выводящая решение в latex;
% -возможно пример реализации чего-то в программе;


    \section{Пример работы программы}
        \input{1.tex}

    % \section{Решение задачи 1}
    % \input{1.tex}
    % \section{Решение задачи 2}
    % \input{2.tex}
    % \section{Решение задачи 9}
    % \input{9.tex}
    % \section{Решение задачи 1 из статьи стр 9}
    % \input{test.tex}
    % \section{Решение задачи о выборе места работы из статьи стр 20}
    % \input{test2.tex}    
    



    \conclusion

    С такой неинтуитивной алгеброй приятно иметь калькулятор.
    
    В ходе решения задачи принятия решений числа могут стать очень большими, что может быть проблемой при больших размерностях входных матриц. Уже разработана более оптимизированная для макс-умножить алгебры структура и ведется ее реализация.



    \renewcommand{\refname}{}
    \vspace{-25pt}
    \bibliographystyle{ugost2008}
    \bibliography{references}
\end{document}